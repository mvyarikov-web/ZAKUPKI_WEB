# Increment 017 — Глобальная дедупликация и полная миграция на новую схему БД

**Дата:** 8 ноября 2025 г.  
**Git commit:** `d3481a2783148eec2d2622bcf45b1ff997b3362c`  
**Дата и время пуша (MSK):** 8 ноября 2025 г., 05:19 MSK

## Постановка

Завершить миграцию на глобальную модель дедупликации документов:
- Один документ на sha256 в таблице `documents` (без owner_id)
- Видимость через таблицу `user_documents` (user_id, document_id, is_soft_deleted)
- Чанки не дублируются глобально (привязаны к document_id)
- Полное удаление legacy колонок owner_id и is_visible из runtime кода
- Создание и валидация комплексного мультипользовательского теста

## Спецификация

### Схема БД (финальная)

**documents** (глобальные документы):
- `id` SERIAL PRIMARY KEY
- `sha256` TEXT UNIQUE NOT NULL
- `size_bytes` BIGINT DEFAULT 0
- `mime` TEXT
- `parse_status` TEXT
- `access_count` INTEGER DEFAULT 0
- `indexing_cost_seconds` DOUBLE PRECISION DEFAULT 0
- `last_accessed_at` TIMESTAMP
- `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP

**user_documents** (видимость для пользователей):
- `user_id` INTEGER NOT NULL
- `document_id` INTEGER NOT NULL REFERENCES documents(id) ON DELETE CASCADE
- `original_filename` TEXT
- `user_path` TEXT
- `is_soft_deleted` BOOLEAN DEFAULT FALSE
- `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
- `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
- UNIQUE(user_id, document_id)

**chunks** (текстовые сегменты):
- `id` SERIAL PRIMARY KEY
- `document_id` INTEGER NOT NULL REFERENCES documents(id) ON DELETE CASCADE
- `chunk_index` INTEGER NOT NULL
- `text` TEXT NOT NULL
- `length` INTEGER DEFAULT 0
- `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
- UNIQUE(document_id, chunk_index)

**folder_index_status** (статус индексации):
- `owner_id` INTEGER NOT NULL
- `folder_path` TEXT NOT NULL
- `root_hash` TEXT
- `last_indexed_at` TIMESTAMP
- UNIQUE(owner_id, folder_path)

### Логика индексации

1. При загрузке файла вычисляется sha256
2. Проверка существования документа: `SELECT id FROM documents WHERE sha256 = ?`
3. Если документ существует → создаём/обновляем user_documents связь (глобальная дедупликация)
4. Если документ новый → создаём documents + user_documents + chunks **в одной транзакции**
5. Chunks создаются только один раз при первой индексации документа

### Изменения в коде

**webapp/services/db_indexing.py:**
- `index_document_to_db()` теперь принимает `user_id, original_filename, user_path`
- Создаёт documents и user_documents в одной транзакции (через `ON CONFLICT DO UPDATE`)
- Chunks записываются сразу после создания документа
- Исправлен SQL синтаксис для INSERT chunks (убрано created_at из VALUES)

**webapp/models/rag_models.py:**
- `initialize_schema()` полностью переписан под новую модель
- Создаёт все 4 таблицы с правильными индексами и внешними ключами

**webapp/__init__.py:**
- Добавлен блок автоматической инициализации схемы при `use_database=True`

**webapp/routes/search.py, admin.py, pages.py:**
- Все запросы мигрированы на JOIN с user_documents
- COUNT(*) FROM documents WHERE owner_id → COUNT(*) FROM user_documents WHERE user_id
- Фильтрация по is_soft_deleted вместо is_visible

### Тестирование

Создан комплексный мультипользовательский тест `tests/test_multi_user_comprehensive.py`:

**10 тестовых сценариев:**
1. `test_01_setup_and_clean` — проверка очистки БД и создания схемы
2. `test_02_user1_indexes_file1` — индексация 2 файлов пользователем 1
3. `test_03_user2_indexes_same_file1` — пользователь 2 индексирует те же файлы (дедупликация)
4. `test_04_search_isolation_user1` — поиск пользователя 1 находит только его документы
5. `test_05_search_isolation_user2` — поиск пользователя 2 находит только его документы
6. `test_06_user3_no_access_to_user1_files` — пользователь 3 не видит чужие файлы
7. `test_07_index_status_per_user` — /index_status показывает правильные количества
8. `test_08_view_index_per_user` — /view_index показывает только файлы текущего user
9. `test_09_soft_delete_and_restore` — мягкое удаление и восстановление связи
10. `test_10_global_dedup_verification` — финальная проверка глобальной дедупликации

**Результат:** ✅ Все 10 тестов прошли успешно

### Ключевые улучшения

1. **Простота и надёжность:** Создание documents и user_documents в одной транзакции исключает race conditions
2. **Глобальная дедупликация:** Один документ на sha256, множество пользователей могут использовать
3. **Изоляция данных:** Каждый пользователь видит только свои документы через user_documents
4. **Мягкое удаление:** is_soft_deleted позволяет скрывать документы без физического удаления
5. **Автоматическая схема:** БД инициализируется автоматически при старте приложения

## Реализация (простыми словами)

### Что изменилось

**До:** Каждый пользователь имел свои копии документов в БД (owner_id), дублирование чанков.

**После:** Документы хранятся глобально (один sha256 = один документ), пользователи получают доступ через связующую таблицу user_documents.

### Основная идея

Представьте библиотеку: книга (документ) существует в единственном экземпляре, но много читателей (пользователей) могут её читать. В базе данных мы храним формуляр (user_documents), где записано: "Пользователь #1 читает книгу #5", "Пользователь #2 читает книгу #5". При этом сама книга хранится один раз.

### Проблема и решение

**Проблема:** При создании документа в одной транзакции, а user_documents связи в другой, возникала ошибка ForeignKeyViolation (документ ещё не виден другой транзакции).

**Решение:** Объединили создание documents и user_documents в одну транзакцию с использованием `ON CONFLICT DO UPDATE`. Теперь всё происходит атомарно и надёжно.

### Тестирование

Комплексный тест проверяет полный жизненный цикл:
1. Пользователь 1 загружает файлы → создаются documents + user_documents + chunks
2. Пользователь 2 загружает те же файлы → переиспользует documents (дедупликация), создаёт свои user_documents
3. Каждый пользователь видит только свои файлы при поиске и просмотре
4. Мягкое удаление (is_soft_deleted=TRUE) скрывает документ без удаления
5. Глобально остаётся 2 документа, 2 чанка, но 4 user_documents связи (по 2 на пользователя)

## Примечания

- Migration выполнена через переписывание `initialize_schema()`, без ALTER TABLE миграций
- Legacy колонки owner_id и is_visible могут оставаться в ORM моделях для исторической совместимости
- GC для orphan documents (документов без user_documents связей) отложен на будущее
- DSN нормализация: автоматическая замена 'postgresql+psycopg2://' на 'postgresql://'

## Статус

✅ **Завершено успешно**

- Схема БД мигрирована
- Runtime код обновлён
- Комплексный тест создан и прошёл (10/10)
- Глобальная дедупликация работает
- Изоляция пользователей подтверждена
