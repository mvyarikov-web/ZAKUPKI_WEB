# Инкремент 009: Оптимизация входного текста для AI-анализа

**Дата создания:** 31 октября 2025 г.

## Постановка

Добавить функцию «Оптимизировать текст» для входного текста (тот, что отправляется в AI). Функция должна снизить длину текста (символы/токены), **не меняя смысл** и порядок содержимого.

### Цель
Снижение затрат на AI-запросы путём удаления технического шума и нормализации текста без потери смысловой информации.

### Проблема
При анализе документов в текст попадает много технического мусора:
- Повторяющиеся хедеры/футеры страниц
- Декоративные линии и рамки
- Избыточные пробелы и переносы строк
- Дефисные переносы слов
- Разная пунктуация для одного и того же

Это увеличивает количество токенов и стоимость запросов без добавления полезной информации.

## Спецификация

### Изменения в UI (экран AI-анализа)

1. **Новая кнопка:**
   - Рядом с кнопкой «Загрузить промпт» добавить кнопку **«Оптимизировать текст»** (`id=btn-optimize-text`)
   - Стиль: вторичная кнопка (secondary)

2. **Модальное окно предпросмотра** (`id=modal-optimize-preview`):
   - Заголовок: "Предпросмотр оптимизации"
   - Область с исходным текстом (readonly, большая)
   - **Подсветка жёлтым** всех фрагментов, которые будут изменены/удалены
   - Статус-строка с метриками:
     * «Символов до: N»
     * «Символов после: M»
     * «Экономия: N−M (X%)»
   - Кнопки:
     * **«Оптимизировать»** (`id=btn-apply-optimization`) — primary
     * **«Отмена»** (`id=btn-cancel-optimization`) — secondary

3. **Потоки работы:**
   - **Клик «Оптимизировать текст»:**
     * Отправить текст на `/ai_analysis/optimize/preview`
     * Показать модалку с результатом
   - **Клик «Оптимизировать» в модалке:**
     * Применить изменения к полю промпта/входного текста
     * Закрыть модалку
     * Показать уведомление: «Оптимизировано: −K символов (−X%)»
   - **Клик «Отмена»:**
     * Закрыть модалку без изменений

### Бэкенд

#### Эндпоинт предпросмотра

**POST `/ai_analysis/optimize/preview`**

**Запрос:**
```json
{
  "text": "<исходный_текст>"
}
```

**Ответ (успех):**
```json
{
  "success": true,
  "optimized_text": "<текст_после_оптимизации>",
  "change_spans": [
    {
      "start": 100,
      "end": 150,
      "reason": "Удалена декоративная линия"
    },
    {
      "start": 200,
      "end": 210,
      "reason": "Схлопнуты множественные пробелы"
    }
  ],
  "chars_before": 5000,
  "chars_after": 4200,
  "reduction_pct": 16.0
}
```

**Ответ (ошибка):**
```json
{
  "success": false,
  "message": "Описание ошибки"
}
```

#### Сервис оптимизации

**Класс `TextOptimizer`** (расположение: `webapp/services/text_optimizer.py`):

```python
class TextOptimizer:
    def optimize(self, text: str) -> OptimizationResult
```

**Возвращает:**
```python
@dataclass
class OptimizationResult:
    optimized_text: str
    change_spans: List[ChangeSpan]
    chars_before: int
    chars_after: int
    reduction_pct: float

@dataclass
class ChangeSpan:
    start: int  # позиция в исходном тексте
    end: int    # позиция в исходном тексте
    reason: str # описание изменения
```

### Правила оптимизации (Safe Mode)

Применяются последовательно, **без потери смысла**:

1. **Нормализация перевода строк и пробелов:**
   - `\r\n` → `\n`
   - Удаление невидимых управляющих символов (кроме `\n`, `\t`)
   - Схлопывание множественных пробелов: `"  +"` → `" "`
   - Схлопывание пустых строк: max 2 подряд

2. **Склейка дефисных переносов:**
   - `сло-\nво` → `слово`
   - Только для русских/латинских слов
   - Сохранение переносов в составных словах (бизнес-план)

3. **Удаление декоративного шума:**
   - Линии: `====...`, `----...`, `____...` (≥5 символов подряд)
   - Псевдографика: строки из `•`, `*`, `#`, `│`, `─` и т.п.
   - Служебные вставки: "Стр. X из Y", "Page X of Y"
   - Сохранение: номера разделов (1.2.3), маркеры списков

4. **Удаление повторяющихся хедеров/футеров:**
   - Определение: строки ≤100 символов, повторяющиеся ≥3 раза
   - Исключение: строки с числами/датами/артикулами
   - Действие: оставляем только первое вхождение

5. **Нормализация пунктуации:**
   - Длинное тире (—, –) → короткое (`-`)
   - NBSP (U+00A0) → обычный пробел
   - Множественные знаки препинания: `...` → `...` (max 3)
   - Сохранение: дефисы в составных словах, точки в сокращениях

6. **Унификация списков:**
   - Различные маркеры (`•`, `*`, `-`, `–`) → `- `
   - Сохранение вложенности по отступам
   - Нумерованные списки не изменяются

### Что НЕЛЬЗЯ делать

❌ **Запрещено:**
- Суммаризация или перефразирование
- Перестановка или переупорядочивание блоков
- Усечение смысловых фрагментов
- Изменение чисел, дат, единиц измерения
- Изменение артикулов, ГОСТов, стандартов
- Удаление технических характеристик
- Изменение структуры таблиц

✅ **Разрешено:**
- Удаление технического шума
- Нормализация форматирования
- Склейка искусственных разрывов
- Унификация синтаксиса

### Подсветка изменений во фронтенде

- Использовать `change_spans` для определения затронутых участков
- Цвет подсветки: `background-color: #fff59d` (жёлтый Material Design)
- Текст в модалке readonly (не редактируемый)
- Подсвечиваются только удаляемые/изменяемые фрагменты

### Обработка ошибок

| Ситуация | Действие |
|----------|----------|
| Пустой текст | Уведомление: "Нет текста для оптимизации" |
| Ошибка API | Уведомление: "Не удалось выполнить оптимизацию. Повторите позже" |
| Очень большой текст (>1MB) | Уведомление: "Текст слишком большой для оптимизации" |
| Нет изменений | Уведомление: "Текст уже оптимален, изменения не требуются" |

## Приёмочные критерии

1. ✅ Кнопка «Оптимизировать текст» отображается рядом с «Загрузить промпт»
2. ✅ Модалка корректно показывает исходный текст с жёлтой подсветкой изменений
3. ✅ Метрики экономии отображаются точно (символы до/после, процент)
4. ✅ «Оптимизировать» → текст заменён, модалка закрыта, показано уведомление
5. ✅ «Отмена» → модалка закрыта, текст не изменён
6. ✅ Экономия ≥20% на типовых документах с повторяющимися служебными вставками
7. ✅ Числа/даты/артикулы/единицы измерения идентичны до и после оптимизации
8. ✅ Порядок смысловых блоков сохранён
9. ✅ Тесты покрывают все правила оптимизации

## Технические детали

### Анализ существующего кода

**Уже реализовано:**
- Кнопка «Оптимизировать текст» (`id=optimizeTextBtn`) в `templates/index.html`
- Модальное окно оптимизации (`id=aiOptimizeModal`)
- Эндпоинт `/ai_analysis/optimize_text` (ручная оптимизация)
- JavaScript обработчики в `static/js/ai-analysis.js`

**Требуется изменить:**
- Заменить ручную оптимизацию на автоматическую по правилам
- Добавить подсветку изменений (жёлтым фоном)
- Изменить логику модалки: показывать текст с подсветкой, а не редактор

### Файлы для создания/изменения

**Новые файлы:**
- `webapp/services/text_optimizer.py` — сервис автоматической оптимизации
- `tests/test_text_optimizer.py` — тесты оптимизатора

**Изменяемые файлы:**
- `webapp/routes/ai_analysis.py` — изменить эндпоинт `/optimize_text` на `/optimize/preview`
- `templates/index.html` — изменить модалку оптимизации под новый функционал
- `static/js/ai-analysis.js` — изменить обработчики для автоматической оптимизации
- `static/css/styles.css` — добавить стили для подсветки изменений

### Зависимости

Все зависимости уже установлены, дополнительных не требуется.

### Производительность

- Обработка текста должна быть потоковой (по строкам/абзацам)
- Для текста до 1MB время обработки ≤ 2 секунды
- Использовать регулярные выражения с компиляцией

## Вне объёма (будущие улучшения)

- Режимы оптимизации (*domain*, *advanced*)
- Дедупликация междокументных абзацев
- Оценка токенов по разным моделям (tiktoken)
- Интеллектуальное чанкование
- История оптимизаций
- Undo/Redo изменений

## Примечания

- Оптимизация должна быть **полностью детерминированной** (один и тот же вход → один и тот же выход)
- Не использовать AI для оптимизации (только правила)
- Код должен быть покрыт unit-тестами минимум на 80%
