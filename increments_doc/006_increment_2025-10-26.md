Хеш коммита:
14dada8

Краткая сводка изменений:
Исправлено отображение выбранной модели (display_name) в интерфейсе и сохранение default_model
Добавлен курс USD/RUB в настройки моделей, расчёт стоимости в рублях
Автоматический fallback на прямой анализ при ошибке эмбеддинга (OpenAI)
Улучшена логика сохранения и загрузки курса, обновления метрик
Добавлен эндпоинт PUT /ai_rag/models/default для смены модели по умолчанию
Хеш коммита:
14dada8


Постановка для GitHub Copilot (без кода)
Цель: Реализовать модуль управления моделями OpenAI. Модуль по кнопке получает список доступных моделей для текущего API-ключа, хранит его во внутреннем файле, позволяет выбрать ровно одну модель (радио-кнопка), и сохраняет вручную заданные цены за входные/выходные токены.
Технические требования
Хранение (один внутренний файл, JSON):
Путь: data/models.json (создавать при первом запуске).
Структура:
{
  "version": 1,
  "selected_model_id": "gpt-4.1-mini",
  "models": [
    {
      "id": "gpt-4.1-mini",
      "label": "GPT-4.1 Mini",
      "available": true,
      "cost_input_per_1k": 0.0,
      "cost_output_per_1k": 0.0,
      "first_seen_at": "2025-10-26T00:00:00Z",
      "last_checked_at": "2025-10-26T00:00:00Z",
      "notes": ""
    }
  ]
}
id — идентификатор модели из OpenAI.
label — человекочитаемое имя (можно = id по умолчанию).
available — доступна ли модель по результатам последнего запроса.
cost_input_per_1k, cost_output_per_1k — цены за 1k входных/выходных токенов (задаём вручную один раз, сохраняем, при обновлениях не перезатирать).
first_seen_at — когда впервые увидели модель.
last_checked_at — когда последний раз проверяли доступность.
notes — произвольные комментарии пользователя.
Требование: запись файла — атомарная (писать во временный файл и переименовывать).
Получение списка моделей (по кнопке, не при старте):
Источник: OpenAI API GET /v1/models с заголовком Authorization: Bearer <OPENAI_API_KEY>.
Сеть вызывать только по действию пользователя «Обновить модели», не автоматически при запуске приложения.
Алгоритм обновления списка (merge, без удаления):
Загрузить текущий models.json (если нет — инициализировать пустой объект).
Запросить актуальные модели у OpenAI → получить массив available_ids.
Пройти по available_ids:
Если id отсутствует в файле → добавить новую запись с:
available = true,
cost_* = 0.0 (или null, если в проекте так принято),
first_seen_at = now, last_checked_at = now.
Если id уже есть → только обновить available = true и last_checked_at = now (цены и label не трогать).
Пройти по существующим моделям, которых нет в available_ids → проставить available = false, last_checked_at = now. Не удалять.
Сохранить файл.
Выбор модели (строго одна):
UI: список моделей с радио-кнопкой (можно выбрать только одну запись).
При клике:
Обновить selected_model_id в models.json.
Если выбранная модель available = false — разрешаем сохранять выбор, но в UI показываем статус «Недоступна» (например, серый текст и/или предупреждение).
В списке рядом с каждой моделью отображать статус: «Доступна»/«Недоступна». Недоступные можно отображать приглушённо.
Редактирование цен:
В UI дать возможность вручную задать/изменить cost_input_per_1k и cost_output_per_1k для выбранной или любой модели.
При сохранении не изменять другие поля модели.
При обновлении списка из API цены сохраняются (не перезаписывать).
Кнопка «Обновить модели»:
Действие пользователя вызывает сетевой запрос и алгоритм из п.3.
В UI показать прогресс/статус (успех/ошибка).
В случае сетевой ошибки: не изменять файл, показать сообщение об ошибке.
Загрузка при старте приложения:
Не обращаться к OpenAI.
Просто прочитать models.json и отобразить текущее состояние (список, отметка выбранной модели, цены, статусы «Доступна/Недоступна» как сохранены).
Публичный интерфейс модуля (названия можно использовать как есть):
load_models_from_file() -> ModelsState
save_models_to_file(state: ModelsState) -> None
fetch_available_models(api_key: str) -> list[str] // обёртка над GET /v1/models
refresh_models(state: ModelsState, api_key: str) -> ModelsState
Выполняет merge по правилам п.3 и возвращает обновлённое состояние (запись в файл — вне функции или внутри по договорённости).
set_selected_model(state: ModelsState, model_id: str) -> ModelsState
update_model_costs(state: ModelsState, model_id: str, cost_input_per_1k: number, cost_output_per_1k: number) -> ModelsState
UI-требования (минимум):
Кнопка «Обновить модели» → вызывает refresh_models(...), затем перерисовать список.
Таблица/список: radio (одиночный выбор), id/label, available (badge), поля цен (редактируемые), кнопка «Сохранить» для цен.
Фильтр/поиск по id (опционально).
Надёжность и валидация:
Если OPENAI_API_KEY отсутствует — не вызывать сеть, показать понятную ошибку.
Обработать 401/403/429/5xx: сообщение пользователю, файл не трогаем.
Валидация чисел цен (неотрицательные). Сохранять в одном формате (например, float с 4 знаками).
Совместимость версии файла: если version не совпадает, выполнить простую миграцию или пересоздать с резервной копией.
Критерии приёмки
 При первом запуске без файла создаётся data/models.json с пустым списком и selected_model_id = null (или отсутствует).
 По нажатию «Обновить модели» в файл добавляются новые модели, существующие помечаются available=true, пропавшие — available=false. Старые записи не удаляются.
 Ручные цены, заданные ранее, сохраняются после обновления.
 Можно выбрать ровно одну модель (радио-кнопка). Выбор сохраняется в файл.
 Недоступные модели отображаются как «Недоступна», выбор возможен, но статус виден.
 Сетевая ошибка не портит файл; пользователь видит понятное уведомление.
 Перезапуск приложения не делает сетевых запросов и корректно читает состояние из файла.
Примечания
Язык реализации — тот же, что у приложения (предпочтительно Python).
Ключ берём из OPENAI_API_KEY (env).
Для HTTP можно использовать штатный SDK или fetch/requests — по месту.
Все названия, поля и структура файла из постановки — обязательны; доп. поля можно добавлять при необходимости, не ломая обратную совместимость.