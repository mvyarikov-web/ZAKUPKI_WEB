# increment-012 — Модуль чтения PDF-документов (векторные и сканы)

Дата и время пуша (MSK): будет заполнено при первом коммите
Git commit hash:

## Постановка

Разработать и интегрировать **отдельный модуль** чтения PDF-документов для проекта ZAKUPKI_WEB, обеспечивающий:
- Автоматическое определение типа PDF: векторный (с текстовым слоем) или графический (скан).
- Извлечение текста:
  - прямое чтение для векторных PDF через каскад экстракторов;
  - OCR для графических PDF (сканов), с поддержкой языков rus+eng.
- Возврат результата в стандартизованной структуре данных с техническими метаданными (время, страницы, используемый экстрактор, попытки).
- Логирование ошибок и показателей производительности.
- **Устранение дублирования кода**: объединение логики из `pdf_utils.py` и `indexer._extract_pdf()` в единый модуль.
- Ненарушающую интеграцию с текущим конвейером индексации и поиска. Любые тяжёлые операции (OCR) выполняются только на этапе индексации, не в HTTP-ручках.

Ограничения и допущения:
- Целевая среда — Python 3.11+; macOS (основная), Linux (CI). Windows — best effort.
- При отсутствии системных зависимостей (poppler/tesseract) модуль должен деградировать грациозно: логировать предупреждение и возвращать пустой текст без падений.
- Производительность: 10 секунд на векторный PDF до 10 страниц; до 30 секунд на OCR для 10 страниц среднего качества (лимиты конфигурируются).
- **Обратная совместимость**: существующие тесты и функциональность приложения не должны сломаться.

### Общая логика работы приложения (контекст интеграции)

**КРИТИЧЕСКИ ВАЖНО**: Модуль чтения PDF **НЕ ДОЛЖЕН** изменять общую логику работы приложения:

**Текущий флоу работы приложения:**
1. **Загрузка файлов** (POST `/upload`):
   - Пользователь загружает файлы различных типов (PDF, DOCX, XLSX, TXT, архивы ZIP/RAR и т.д.)
   - Файлы сохраняются в папку `uploads/` (поддерживаемые) или `uploads/unsupported/` (неподдерживаемые)
   - На этом этапе **НЕТ чтения/распознавания** содержимого файлов

2. **Построение индекса** (POST `/build_index`):
   - Пользователь явно нажимает кнопку "Построить индекс" в UI
   - Вызывается `DocumentProcessor().create_search_index(uploads_folder)`
   - Для каждого файла в `uploads/` (включая файлы из архивов):
     - Извлекается текстовое содержимое
     - Применяется OCR для сканов PDF (если доступен tesseract)
     - Извлекается текст из DOCX, XLSX, TXT и других поддерживаемых форматов
   - Создаётся **единый сводный файл** `index/_search_index.txt` со всем текстом и метаданными
   - Этот этап **тяжёлый** — может занимать минуты для больших наборов файлов

3. **Поиск** (POST `/search`):
   - Пользователь вводит ключевые слова в поисковую строку
   - Вызывается `Searcher().search(index_path, keywords)`
   - Поиск выполняется **ТОЛЬКО по индексному файлу** `index/_search_index.txt`
   - **Исходные файлы НЕ читаются повторно** — всё уже есть в индексе
   - Возвращаются найденные совпадения с контекстом (сниппетами)

4. **Отображение результатов** (GET `/result/<path>`):
   - Показываются файлы с найденными ключевыми словами
   - Сниппеты с контекстом вокруг совпадений
   - Метаданные (формат, размер, дата, использовался ли OCR)

**Роль модуля pdf_reader в этом флоу:**
- Модуль вызывается **ТОЛЬКО на этапе 2** (построение индекса)
- Вызов происходит в `indexer._extract_text()` для файлов с расширением `.pdf`
- Модуль возвращает извлечённый текст, который записывается в `_search_index.txt`
- После построения индекса модуль **НЕ участвует** в работе приложения до следующей переиндексации

**Гарантии неизменности логики:**
- ✅ Загрузка файлов — без изменений (pdf_reader не вызывается)
- ✅ Построение индекса — замена внутренней логики извлечения текста из PDF (без изменения API)
- ✅ Поиск — без изменений (работает с готовым индексом, pdf_reader не вызывается)
- ✅ HTTP-ручки — без изменений (pdf_reader вызывается внутри indexer, не в routes)
- ✅ UI — без изменений (все изменения инкапсулированы в бэкенде)
- ✅ Другие форматы (DOCX, XLSX, TXT, архивы) — без изменений

**Критерий успеха:**
После интеграции pdf_reader пользователь **НЕ ДОЛЖЕН** заметить изменений в работе приложения, кроме:
- Более качественного извлечения текста из PDF (благодаря каскаду экстракторов)
- Поддержки OCR для сканированных PDF (если установлен tesseract)
- Более детальных метаданных в логах (используемый экстрактор, время обработки)

## Спецификация

### 1. Архитектура и размещение (отдельный модуль)

**Новый выделенный модуль для PDF:**
- document_processor/pdf_reader/ — новая папка модуля чтения PDF
  - __init__.py — публичный API модуля
  - reader.py — класс PdfReader с методами:
    - read_pdf(path, ocr='auto', lang='rus+eng', budget_seconds=10.0) -> PdfReadResult
    - has_text_layer(path, sample_pages=2, min_text_len=50) -> bool
    - _extract_text_vector(path, budget_seconds) -> Dict (каскад: pdfplumber → pypdf → pdfminer → PyMuPDF)
    - _extract_text_ocr(path, max_pages, lang) -> str
  - analyzer.py — класс PdfAnalyzer:
    - analyze_pdf(path) -> Dict — быстрый анализ (is_pdf, pages, encrypted, producer, linearized)
  - exceptions.py — исключения модуля (PdfReadError, OcrNotAvailableError)

**Рефакторинг существующих модулей (устранение дублирования):**

**Чек-лист дублирования для устранения:**

| Файл | Дублирующая логика | Действие |
|------|-------------------|----------|
| pdf_utils.py | analyze_pdf() — 90 строк | ПЕРЕМЕСТИТЬ в pdf_reader/analyzer.py |
| pdf_utils.py | extract_text_pdf() — 110 строк | ПЕРЕМЕСТИТЬ в pdf_reader/reader.py |
| pdf_utils.py | Каскад pdfplumber→pypdf→pdfminer→PyMuPDF | ПЕРЕМЕСТИТЬ в pdf_reader/reader.py |
| indexer.py | _extract_pdf() — 60 строк | УДАЛИТЬ, заменить на PdfReader().read_pdf() |
| indexer.py | Каскад pdfplumber→pypdf→fitz | УДАЛИТЬ (дублирует pdf_utils) |
| indexer.py | Логика определения is_encrypted | УДАЛИТЬ (использовать PdfAnalyzer) |

**document_processor/pdf_utils.py — изменения:**
```python
# ДО (текущее состояние — ДУБЛИРОВАНИЕ):
# - analyze_pdf() — 90 строк
# - extract_text_pdf() — 110 строк
# - Каскад экстракторов внутри extract_text_pdf()

# ПОСЛЕ (без дублирования):
from .pdf_reader import PdfReader, PdfAnalyzer

# Обратная совместимость для старого кода
def analyze_pdf(path: str):
    """Deprecated: use PdfAnalyzer().analyze_pdf() directly."""
    return PdfAnalyzer().analyze_pdf(path)

def extract_text_pdf(path: str, budget_seconds: float = 5.0):
    """Deprecated: use PdfReader().read_pdf() directly."""
    result = PdfReader().read_pdf(path, ocr='off', budget_seconds=budget_seconds)
    return {
        'text': result['text'],
        'used_extractor': result['used_extractor'],
        'elapsed_ms': result['elapsed_ms'],
        'attempts': result['attempts']
    }

# Оставить только build_pdf_response() — это не дублирование
def build_pdf_response(path: str, filename: str, inline: bool = True, enable_range: bool = True):
    # ...existing code...
```

**document_processor/search/indexer.py — изменения:**
```python
# ДО (текущее состояние — ДУБЛИРОВАНИЕ):
# def _extract_pdf(self, path: str, max_pages: int = 100) -> str:
#     try:
#         import pdfplumber
#         # ... 30 строк каскада
#     except:
#         try:
#             import pypdf
#             # ... 30 строк каскада
#         except:
#             try:
#                 import fitz
#                 # ... 15 строк

# ПОСЛЕ (без дублирования):
def _extract_text(self, abs_path: str, rel_path: str, ext: str, source: str):
    # ...existing code...
    
    if ext == "pdf":
        from ..pdf_reader import PdfReader
        
        # Получить настройки из конфига
        config = getattr(self, '_config', None)
        budget = getattr(config, 'PDF_TEXT_TIMEOUT_S', 5) if config else 5
        max_ocr = getattr(config, 'PDF_OCR_MAX_PAGES', 2) if config else 2
        lang = getattr(config, 'PDF_OCR_LANG', 'rus+eng') if config else 'rus+eng'
        max_pages = getattr(config, 'PDF_MAX_PAGES_TEXT', 100) if config else 100
        
        # Единая точка вызова вместо дублирующего кода
        reader = PdfReader()
        result = reader.read_pdf(
            path=abs_path,
            ocr='auto',
            lang=lang,
            budget_seconds=budget,
            max_pages_text=max_pages,
            max_pages_ocr=max_ocr
        )
        
        text = result['text']
        ocr_used = result['ocr_used']
        
        # УДАЛИТЬ старую логику:
        # - Больше НЕ вызывать self._extract_pdf()
        # - Больше НЕ использовать fallback на pdfminer
        # - Всё это уже внутри PdfReader
```

**Проверка устранения дублирования:**
```bash
# Поиск дублирующего кода после рефакторинга:
grep -r "import pdfplumber" document_processor/
# Должно остаться только в pdf_reader/reader.py

grep -r "import pypdf" document_processor/
# Должно остаться только в pdf_reader/reader.py и pdf_reader/analyzer.py

grep -r "def.*extract.*pdf" document_processor/
# Должно остаться только в pdf_reader/reader.py и алиас в pdf_utils.py

# Подсчёт строк кода ДО и ПОСЛЕ:
# ДО: pdf_utils.py (224 строки) + indexer._extract_pdf (60 строк) = 284 строки
# ПОСЛЕ: pdf_reader/reader.py (~150 строк) + алиасы (~20 строк) = 170 строк
# ВЫГОДА: -114 строк (-40% дублирования)
```

**Конфигурация (webapp/config.py):**
Добавить новые настройки в класс Config:
```python
# PDF Processing
PDF_TEXT_TIMEOUT_S = 5  # тайм-бюджет для извлечения текста из векторных PDF
PDF_OCR_ENABLED = True  # включить OCR для сканов
PDF_OCR_MAX_PAGES = 2   # максимум страниц для OCR (оптимизация)
PDF_OCR_LANG = 'rus+eng'  # языки для Tesseract
PDF_TEXT_MIN_LEN = 50   # порог минимальной длины текста (ниже — считать сканом)
PDF_MAX_PAGES_TEXT = 100  # лимит страниц для векторного извлечения
```

### 2. Контракты данных (ввод/вывод)

**Главный интерфейс модуля:**
```python
from document_processor.pdf_reader import PdfReader

reader = PdfReader()
result = reader.read_pdf(
    path='document.pdf',
    ocr='auto',  # 'auto' | 'force' | 'off'
    lang='rus+eng',
    budget_seconds=10.0,
    max_pages_text=100,  # для векторного извлечения
    max_pages_ocr=2      # для OCR
)
```

**Структура PdfReadResult (dict):**
```python
{
    'text': str,              # извлечённый текст (UTF-8, нормализованный)
    'pages': int | None,      # общее количество страниц в PDF
    'ocr_used': bool,         # True если применялся OCR
    'used_extractor': str,    # 'pdfplumber' | 'pypdf' | 'pdfminer' | 'pymupdf' | 'ocr' | 'none'
    'elapsed_ms': int,        # общее время обработки в миллисекундах
    'has_text_layer': bool,   # результат определения типа PDF
    'attempts': [             # журнал попыток извлечения
        {
            'name': str,           # имя экстрактора
            'ok': bool,            # успешность попытки
            'elapsed_ms': int,     # время попытки
            'error': str | None    # текст ошибки при неудаче
        }
    ]
}
```

**Обработка ошибок:**
- Исключения наружу НЕ выбрасывать — возвращать result с ok=False в attempts и пустым text
- Логировать через корневой логгер (уже настроен в приложении → logs/app.log)
- При отсутствии системных зависимостей (tesseract/poppler) — graceful degrade, логировать WARNING

**Обратная совместимость:**
- Для старого кода можно импортировать: `from document_processor.pdf_utils import extract_text_pdf`
- Внутри pdf_utils.py сделать алиас на PdfReader().read_pdf() для совместимости

### 3. Функциональность

**Определение типа PDF:**
- Метод has_text_layer(path, sample_pages=2, min_text_len=50) -> bool
- Проверяет наличие текста на sample_pages (по умолчанию первые 2)
- Если суммарная длина текста >= min_text_len → True (векторный)
- Иначе → False (скан)

**Каскадные экстракторы для векторных PDF:**
- Порядок попыток (по скорости/качеству): pdfplumber → pypdf → pdfminer → PyMuPDF
- Каждый экстрактор ограничен остатком тайм-бюджета
- Если один экстрактор вернул текст → прекратить попытки, использовать результат
- Все попытки логируются в result['attempts']

**OCR для сканов:**
- Используется, если: has_text_layer() == False ИЛИ ocr='force'
- Конвертация: pdf2image.convert_from_path(path) → изображения первых max_pages_ocr страниц
- Распознавание: pytesseract.image_to_string(img, lang=lang) для каждой страницы
- Языки: по умолчанию 'rus+eng', конфигурируемо
- Graceful degrade: если pytesseract/pdf2image/poppler отсутствуют → логировать WARNING, вернуть пустой текст

**Нормализация текста:**
- Унификация Unicode: unicodedata.normalize('NFKC', text)
- Удаление невидимых символов: `\x00-\x08`, `\x0B-\x0C`, `\x0E-\x1F`, `\x7F`
- Схлопывание пробелов: `\s+` → один пробел
- Trim: удалить пробелы в начале и конце

**Логирование:**
- INFO: старт чтения PDF, финиш (extractor, ocr_used, elapsed_ms, pages)
- DEBUG: каждая попытка экстрактора (name, ok, elapsed_ms, error)
- WARNING: отсутствие OCR-зависимостей, превышение тайм-бюджета
- ERROR: критические ошибки с трейсбэком (через logger.exception)

### 4. Производительность и лимиты
- Тайм-бюджеты: общий budget_seconds, внутри — динамическое распределение между попытками; принудительное прекращение, если бюджет исчерпан.
- OCR ограничивать по страницам (PDF_OCR_MAX_PAGES) и языкам; при большом документе предложить пользователю настроить лимиты.

### 5. Интеграция с Indexer (без нарушения текущей работы)

**document_processor/search/indexer.py — изменения:**

1. **УДАЛИТЬ дублирующий метод _extract_pdf()**:
   - Полностью удалить метод _extract_pdf(path, max_pages) — логика переносится в pdf_reader
   
2. **В методе _extract_text() для ext == 'pdf':**
   ```python
   if ext == "pdf":
       from ..pdf_reader import PdfReader
       reader = PdfReader()
       
       # Получить настройки из конфига (если доступны) или использовать дефолты
       config = getattr(self, '_config', None)
       budget = getattr(config, 'PDF_TEXT_TIMEOUT_S', 5) if config else 5
       max_ocr = getattr(config, 'PDF_OCR_MAX_PAGES', 2) if config else 2
       lang = getattr(config, 'PDF_OCR_LANG', 'rus+eng') if config else 'rus+eng'
       
       result = reader.read_pdf(
           path=abs_path,
           ocr='auto',
           lang=lang,
           budget_seconds=budget,
           max_pages_ocr=max_ocr
       )
       
       text = result['text']
       ocr_used = result['ocr_used']
   ```

3. **Сохранить совместимость метаданных:**
   - meta: {format:'PDF', length:int, date:str, ocr:bool, quality:int, source:str}
   - Значение meta['ocr'] = result['ocr_used'] из PdfReader

4. **Обработка PDF из архивов (ZIP/RAR) — КРИТИЧЕСКИ ВАЖНО:**
   - Текущая реализация в indexer._iter_archive() извлекает файлы из архивов во временные файлы через _write_temp_file()
   - PDF-файлы внутри архивов попадают в _extract_text() с параметром abs_path = путь к временному файлу
   - **PdfReader должен корректно работать с временными PDF-файлами:**
     - Временные файлы создаются с суффиксом `.pdf` через tempfile.mkstemp(suffix='.pdf')
     - PdfReader получает абсолютный путь к временному файлу, как к обычному PDF
     - Источник (source) сохраняется в формате `zip://путь/к/архиву!/путь/в/архиве.pdf` или `rar://...`
   - **Тестирование обработки PDF из архивов:**
     - Создать тест test_pdf_from_archive.py:
       - Создать ZIP с векторным PDF внутри
       - Создать ZIP со сканом PDF внутри
       - Проверить, что индексация корректно извлекает текст
       - Проверить, что в метаданных source содержит `zip://` или `rar://`
     - Убедиться, что временные файлы корректно очищаются после индексации (indexer._cleanup_temp_paths())
   - **Важно:** PdfReader не должен знать об архивах — он работает с обычными файловыми путями. Логика архивов остаётся в indexer._iter_archive()

5. **_ocr_pdf_pages() — ОПЦИОНАЛЬНО:**
   - Можно оставить для явных вызовов в особых случаях
   - Или переделать как обёртку над pdf_reader.PdfReader()._extract_text_ocr()

**HTTP-ручки и UI:**
- Без изменений
- Тяжёлые операции (OCR, чтение PDF) только в POST /build_index
- В routes не добавляются новые ручки для PDF (всё через индексацию)

**Логирование:**
- PdfReader пишет в корневой логгер → logs/app.log (уже настроен)
- Уровни: INFO для старта/финиша, DEBUG для попыток, WARNING при отсутствии зависимостей

### 6. Установка зависимостей (полная инструкция)

**requirements.txt — проверить и дополнить при необходимости:**
```txt
Flask==2.3.3
python-docx==0.8.11
openpyxl==3.1.2
pypdf==5.0.1
pdfplumber==0.11.7
pdfminer.six==20250506
PyMuPDF==1.24.0
Werkzeug==2.3.7
docx2txt==0.8
chardet==5.2.0
rarfile==4.2
pytest-timeout==2.1.0

# Опциональные для OCR (graceful degrade если отсутствуют):
pytesseract==0.3.10
Pillow==10.4.0
pdf2image==1.17.0
```

**Системные зависимости:**

**macOS (Homebrew):**
```bash
# Обновить Homebrew
brew update

# Установить poppler (для pdf2image) и tesseract (для OCR)
brew install poppler tesseract tesseract-lang

# Проверка установки
which pdftoppm  # должен вернуть путь к исполняемому файлу
tesseract --version  # должен показать версию

# Русские данные для Tesseract обычно уже включены в tesseract-lang
# Если нет, скачайте вручную:
# wget https://github.com/tesseract-ocr/tessdata/raw/main/rus.traineddata
# И положите в: /opt/homebrew/share/tessdata/ (Apple Silicon) или /usr/local/share/tessdata/ (Intel)
```

**Ubuntu/Debian:**
```bash
sudo apt-get update
sudo apt-get install -y \
    poppler-utils \
    tesseract-ocr \
    tesseract-ocr-rus \
    tesseract-ocr-eng

# Проверка
which pdftoppm
tesseract --version
```

**CentOS/RHEL:**
```bash
sudo yum install -y epel-release
sudo yum install -y poppler-utils tesseract tesseract-langpack-rus
```

**Переменные окружения (при необходимости):**
```bash
# Если Tesseract не находит языковые данные автоматически:
export TESSDATA_PREFIX=/usr/share/tesseract-ocr/4.00/tessdata  # Ubuntu/Debian
export TESSDATA_PREFIX=/opt/homebrew/share/tessdata            # macOS (Apple Silicon)
export TESSDATA_PREFIX=/usr/local/share/tessdata               # macOS (Intel)

# Добавить в ~/.zshrc или ~/.bashrc для постоянного использования
```

**Установка Python-зависимостей в виртуальном окружении:**
```bash
cd /path/to/web_interface

# Создать виртуальное окружение
python3 -m venv .venv

# Активировать
source .venv/bin/activate  # macOS/Linux
# или
.venv\Scripts\activate     # Windows

# Обновить pip
pip install --upgrade pip setuptools wheel

# Установить все зависимости
pip install -r requirements.txt

# Проверка установки критичных пакетов
python -c "import pypdf; print('pypdf OK')"
python -c "import pdfplumber; print('pdfplumber OK')"
python -c "import pdfminer; print('pdfminer OK')"
python -c "import fitz; print('PyMuPDF OK')"

# Опциональные (для OCR)
python -c "import pytesseract; print('pytesseract OK')" || echo "pytesseract не установлен (опционально)"
python -c "import pdf2image; print('pdf2image OK')" || echo "pdf2image не установлен (опционально)"
```

**Проверка готовности системы:**
```bash
# Скрипт проверки зависимостей (можно создать tests/check_deps.py):
python3 << 'EOF'
import sys

deps_ok = True
optional_ok = True

# Обязательные
for mod in ['pypdf', 'pdfplumber', 'pdfminer', 'fitz']:
    try:
        __import__(mod)
        print(f"✓ {mod}")
    except ImportError:
        print(f"✗ {mod} — ОТСУТСТВУЕТ")
        deps_ok = False

# Опциональные (для OCR)
for mod in ['pytesseract', 'pdf2image', 'PIL']:
    try:
        __import__(mod)
        print(f"✓ {mod} (OCR)")
    except ImportError:
        print(f"⚠ {mod} — отсутствует (OCR не будет работать)")
        optional_ok = False

if not deps_ok:
    print("\n❌ Критичные зависимости отсутствуют!")
    sys.exit(1)
elif not optional_ok:
    print("\n⚠️  OCR-зависимости отсутствуют, но базовая работа возможна")
else:
    print("\n✅ Все зависимости установлены корректно")
EOF
```

### 7. Тестирование (pytest) — только необходимые тесты с таймаутами

**Стратегия тестирования:**
- Минимальный набор быстрых тестов (по умолчанию в pytest.ini)
- OCR-тесты помечать skipif при отсутствии зависимостей
- Все тесты с timeout для предотвращения зависаний
- Проверка обратной совместимости с существующими тестами

**Новые тесты для модуля pdf_reader:**

**tests/test_pdf_reader_module.py** (основные быстрые тесты, ~5-10 сек):
```python
import pytest
from pathlib import Path
from document_processor.pdf_reader import PdfReader

@pytest.mark.timeout(10)
def test_pdf_reader_vector_basic(tmp_path):
    """Векторный PDF: извлечение текста, проверка has_text_layer=True, ocr_used=False."""
    # Создать минимальный векторный PDF с текстом (или использовать фикстуру)
    # Проверить: result['text'] != '', result['ocr_used'] == False
    # Проверить: result['used_extractor'] in ['pdfplumber', 'pypdf', 'pdfminer', 'pymupdf']
    pass

@pytest.mark.timeout(10)
def test_pdf_reader_has_text_layer(tmp_path):
    """Определение наличия текстового слоя."""
    # Создать векторный PDF
    # assert reader.has_text_layer(path) == True
    # Создать сканированный PDF (пустой текст)
    # assert reader.has_text_layer(path) == False
    pass

@pytest.mark.timeout(5)
def test_pdf_reader_empty_pdf(tmp_path):
    """Пустой PDF: нет исключений, пустой текст."""
    # result = reader.read_pdf(empty_pdf_path)
    # assert result['text'] == ''
    # assert result['used_extractor'] == 'none'
    # assert len(result['attempts']) > 0
    pass

@pytest.mark.timeout(5)
def test_pdf_reader_corrupted_pdf(tmp_path):
    """Повреждённый PDF: graceful handling, no exceptions."""
    # Создать файл с битыми данными
    # result = reader.read_pdf(broken_path)
    # assert result['text'] == ''
    # assert any(a['error'] is not None for a in result['attempts'])
    pass
```

**tests/test_pdf_reader_ocr.py** (OCR-тесты, только при наличии зависимостей):
```python
import pytest
import os

# Проверка доступности OCR-зависимостей
try:
    import pytesseract
    import pdf2image
    OCR_AVAILABLE = True
except ImportError:
    OCR_AVAILABLE = False

@pytest.mark.skipif(not OCR_AVAILABLE, reason="OCR dependencies not installed")
@pytest.mark.timeout(30)
def test_pdf_reader_ocr_scan(tmp_path):
    """Сканированный PDF: OCR извлекает текст, ocr_used=True."""
    # Создать PDF со сканом (изображением с текстом)
    # result = reader.read_pdf(scan_path, ocr='auto')
    # assert result['ocr_used'] == True
    # assert len(result['text']) > 0
    # assert result['used_extractor'] == 'ocr'
    pass

@pytest.mark.skipif(not OCR_AVAILABLE, reason="OCR dependencies not installed")
@pytest.mark.timeout(30)
def test_pdf_reader_ocr_force(tmp_path):
    """Принудительный OCR даже для векторного PDF."""
    # result = reader.read_pdf(vector_path, ocr='force')
    # assert result['ocr_used'] == True
    pass
```

**tests/test_indexer_pdf_refactored.py** (интеграционный, проверка обратной совместимости):
```python
import pytest
from document_processor import DocumentProcessor

@pytest.mark.timeout(15)
def test_indexer_uses_pdf_reader_module(tmp_path):
    """Проверка, что Indexer использует новый pdf_reader без дублирования."""
    root = tmp_path / "docs"
    root.mkdir()
    
    # Создать векторный PDF
    pdf_file = root / "test.pdf"
    # ... создание тестового PDF
    
    dp = DocumentProcessor()
    index_path = dp.create_search_index(str(root))
    
    # Проверить: индекс создан, PDF обработан, meta.ocr корректно
    content = Path(index_path).read_text(encoding='utf-8')
    assert 'ЗАГОЛОВОК: test.pdf' in content
    assert 'OCR: нет' in content  # для векторного PDF
    pass

@pytest.mark.timeout(15)
def test_existing_tests_not_broken(tmp_path):
    """Проверка, что существующие тесты работают после рефакторинга."""
    # Запустить test_indexer_basic.py, test_pdf_pypdf_fallback.py
    # Убедиться, что они проходят без изменений
    pass
```

**tests/test_pdf_from_archive.py** (критически важный тест для PDF из ZIP/RAR):
```python
import pytest
import zipfile
from pathlib import Path
from document_processor import DocumentProcessor

@pytest.mark.timeout(20)
def test_pdf_from_zip_vector(tmp_path):
    """Векторный PDF внутри ZIP-архива: корректное извлечение и индексация."""
    root = tmp_path / "docs"
    root.mkdir()
    
    # Создать простой векторный PDF
    pdf_file = tmp_path / "document.pdf"
    # ... создание тестового PDF с текстом "Test content"
    
    # Упаковать в ZIP
    zip_file = root / "archive.zip"
    with zipfile.ZipFile(zip_file, 'w') as zf:
        zf.write(pdf_file, arcname="document.pdf")
    
    # Индексировать
    dp = DocumentProcessor()
    index_path = dp.create_search_index(str(root))
    
    # Проверки
    content = Path(index_path).read_text(encoding='utf-8')
    assert 'zip://archive.zip!/document.pdf' in content or 'archive.zip!/document.pdf' in content
    assert 'Test content' in content  # текст из PDF должен быть извлечён
    assert 'Формат: PDF' in content
    assert 'OCR: нет' in content  # для векторного PDF
    
    # Проверка поиска
    results = dp.search_keywords(index_path, ['Test', 'content'])
    assert len(results) > 0
    assert any('zip://' in r['file'] or '!/document.pdf' in r['file'] for r in results)

@pytest.mark.timeout(30)
@pytest.mark.skipif(not OCR_AVAILABLE, reason="OCR dependencies not installed")
def test_pdf_scan_from_zip_with_ocr(tmp_path):
    """Сканированный PDF внутри ZIP: корректная обработка через OCR."""
    root = tmp_path / "docs"
    root.mkdir()
    
    # Создать PDF-скан (изображение с текстом)
    pdf_scan = tmp_path / "scan.pdf"
    # ... создание тестового PDF-скана
    
    # Упаковать в ZIP
    zip_file = root / "scans.zip"
    with zipfile.ZipFile(zip_file, 'w') as zf:
        zf.write(pdf_scan, arcname="scan.pdf")
    
    # Индексировать
    dp = DocumentProcessor()
    index_path = dp.create_search_index(str(root))
    
    # Проверки
    content = Path(index_path).read_text(encoding='utf-8')
    assert 'zip://scans.zip!/scan.pdf' in content or 'scans.zip!/scan.pdf' in content
    assert 'Формат: PDF' in content
    assert 'OCR: да' in content  # OCR должен был сработать

@pytest.mark.timeout(20)
def test_pdf_from_nested_zip(tmp_path):
    """PDF внутри вложенного ZIP (архив в архиве)."""
    root = tmp_path / "docs"
    root.mkdir()
    
    # Создать PDF
    pdf_file = tmp_path / "nested.pdf"
    # ... создание тестового PDF
    
    # Создать внутренний ZIP
    inner_zip = tmp_path / "inner.zip"
    with zipfile.ZipFile(inner_zip, 'w') as zf:
        zf.write(pdf_file, arcname="nested.pdf")
    
    # Упаковать в внешний ZIP
    outer_zip = root / "outer.zip"
    with zipfile.ZipFile(outer_zip, 'w') as zf:
        zf.write(inner_zip, arcname="inner.zip")
    
    # Индексировать (с учётом archive_depth > 0)
    dp = DocumentProcessor()
    index_path = dp.create_search_index(str(root))
    
    # Проверка: вложенный PDF должен быть обработан (если archive_depth позволяет)
    content = Path(index_path).read_text(encoding='utf-8')
    # Формат источника: zip://outer.zip!/inner.zip!/nested.pdf
    assert 'nested.pdf' in content
```

**Обновление pytest.ini:**
```ini
[pytest]
minversion = 7.0
testpaths = tests
python_files = test_indexer_basic.py test_searcher.py test_flask_endpoints.py test_download_endpoint.py test_server_config.py test_pdf_reader_module.py test_indexer_pdf_refactored.py test_pdf_from_archive.py
addopts = -q
timeout = 30
timeout_method = signal
```

**Метки и стратегия:**
- `@pytest.mark.timeout(N)` для всех тестов (5-30 сек в зависимости от операции)
- `@pytest.mark.skipif(not OCR_AVAILABLE, ...)` для OCR-тестов
- Быстрые тесты (~5-10 сек) запускаются по умолчанию
- OCR-тесты (~30 сек) запускаются только если зависимости установлены
- Интеграционные тесты проверяют, что рефакторинг не сломал существующую функциональность

**Проверка корректности работы:**
1. Запустить базовый набор: `pytest tests/test_pdf_reader_module.py -v`
2. Запустить с OCR (если доступен): `pytest tests/test_pdf_reader_ocr.py -v`
3. Запустить все дефолтные тесты: `pytest -v`
4. Проверить обратную совместимость: `pytest tests/test_pdf_pypdf_fallback.py tests/test_resilience_broken_files.py -v`

### 8. Безопасность и надёжность
- Не выполнять OCR, если путь/файл недоступен; все ошибки — в лог, без падений.
- Фильтровать/нормализовать текст (UTF‑8) — без бинарных артефактов.
- Не читать огромные файлы в память целиком без необходимости; потоковая обработка страниц.
- Валидация путей: проверка существования файла перед обработкой.
- Защита от зависаний: строгие тайм-бюджеты для всех операций.
- Изоляция ошибок: исключения в одном экстракторе не прерывают попытки других.

### 8.1. Проверка корректной работы приложения (мануальное тестирование)

**Сценарий 1: Базовая функциональность (без OCR)**
1. Запустить сервер: `python3 app.py`
2. Открыть http://localhost:8081
3. Загрузить несколько PDF-файлов (векторные с текстом)
4. Нажать «Построить индекс»
5. Проверить:
   - ✅ Индекс создан успешно
   - ✅ В логах нет ошибок
   - ✅ В интерфейсе отображаются загруженные файлы
   - ✅ Метаданные корректны (OCR: нет для векторных PDF)
6. Выполнить поиск по ключевым словам из PDF
7. Проверить:
   - ✅ Поиск находит совпадения
   - ✅ Сниппеты отображаются корректно
   - ✅ Можно открыть найденный документ

**Сценарий 2: Работа с OCR (если установлен tesseract)**
1. Загрузить сканированный PDF (без текстового слоя)
2. Нажать «Построить индекс»
3. Проверить:
   - ✅ Индекс создан успешно
   - ✅ В метаданных указано OCR: да
   - ✅ Текст из скана распознан (хотя бы частично)
   - ✅ Поиск по распознанному тексту работает

**Сценарий 3: Graceful degradation (без tesseract)**
1. Убедиться, что tesseract НЕ установлен: `which tesseract` → not found
2. Загрузить сканированный PDF
3. Нажать «Построить индекс»
4. Проверить:
   - ✅ Приложение не падает
   - ✅ В логах WARNING о отсутствии OCR-зависимостей
   - ✅ Файл добавлен в индекс (пустой текст)
   - ✅ Векторные PDF обрабатываются нормально

**Сценарий 4: Производительность**
1. Загрузить 10-15 PDF разного размера (векторные + сканы)
2. Засечь время индексации
3. Проверить:
   - ✅ Индексация завершается за разумное время (≤ 2 мин для 15 файлов)
   - ✅ Тайм-бюджеты соблюдаются (нет зависаний)
   - ✅ Логи показывают время обработки каждого файла

**Сценарий 5: PDF из архивов (КРИТИЧНО)**
1. Создать ZIP-архив с несколькими PDF внутри (векторные и сканы)
2. Загрузить ZIP через веб-интерфейс
3. Нажать «Построить индекс»
4. Проверить:
   - ✅ Все PDF из архива обработаны корректно
   - ✅ В метаданных источник имеет формат `zip://archive.zip!/file.pdf`
   - ✅ Векторные PDF: текст извлечён, OCR: нет
   - ✅ Сканы PDF: текст распознан (если есть OCR), OCR: да
   - ✅ Временные файлы очищены после индексации (проверить `/tmp` или аналог)
5. Выполнить поиск по тексту из PDF внутри архива
6. Проверить:
   - ✅ Поиск находит совпадения
   - ✅ Результаты отображают правильный источник (zip://...)
   - ✅ Сниппеты корректны
7. Проверить вложенные архивы (ZIP внутри ZIP с PDF):
   - ✅ Если archive_depth > 0: вложенные PDF обрабатываются
   - ✅ Источник имеет формат `zip://outer.zip!/inner.zip!/file.pdf`

**Сценарий 6: Обратная совместимость**
1. Запустить существующие тесты: `pytest -v`
2. Проверить:
   - ✅ Все дефолтные тесты проходят
   - ✅ test_pdf_pypdf_fallback.py проходит
   - ✅ test_resilience_broken_files.py проходит
   - ✅ test_indexer_basic.py проходит
3. Проверить функциональность, НЕ связанную с PDF:
   - ✅ Загрузка DOCX/XLSX работает
   - ✅ Загрузка архивов ZIP/RAR работает
   - ✅ Удаление файлов работает
   - ✅ Скачивание файлов работает

**Сценарий 7: Проверка общего флоу работы приложения (КРИТИЧНО)**
1. **Этап 1 — Загрузка файлов (без обработки):**
   - Создать тестовую папку с файлами: 3 PDF (векторные + скан), 2 DOCX, 1 XLSX, 1 ZIP с PDF внутри
   - Загрузить через веб-интерфейс (POST /upload)
   - Проверить:
     - ✅ Файлы появились в папке `uploads/`
     - ✅ В логах НЕТ записей о чтении содержимого (pdf_reader НЕ вызывался)
     - ✅ UI показывает загруженные файлы, но без статусов поиска

2. **Этап 2 — Построение индекса (единственное место обработки):**
   - Нажать кнопку «Построить индекс» (POST /build_index)
   - Дождаться завершения
   - Проверить:
     - ✅ Создан файл `index/_search_index.txt`
     - ✅ В логах есть записи о чтении PDF через pdf_reader (INFO: "Чтение PDF...", "Использован экстрактор: ...")
     - ✅ Индекс содержит текст из всех файлов (PDF, DOCX, XLSX, файлы из архивов)
     - ✅ Для каждого файла есть заголовок, метаданные (Формат, Символов, OCR, Качество)
     - ✅ Исходные файлы в `uploads/` НЕ изменились

3. **Этап 3 — Поиск (работа только с индексом):**
   - Ввести ключевые слова, которые есть в загруженных PDF
   - Выполнить поиск (POST /search)
   - Проверить:
     - ✅ Поиск мгновенный (< 1 сек), не зависит от количества/размера исходных файлов
     - ✅ В логах НЕТ записей о чтении исходных файлов (pdf_reader НЕ вызывался)
     - ✅ Найдены совпадения с правильными сниппетами
     - ✅ Результаты содержат метаданные из индекса (формат, OCR)

4. **Этап 4 — Повторный поиск (без переиндексации):**
   - Выполнить поиск с другими ключевыми словами
   - Проверить:
     - ✅ Поиск работает мгновенно
     - ✅ Индекс НЕ пересоздаётся
     - ✅ Исходные файлы НЕ читаются

5. **Этап 5 — Добавление новых файлов:**
   - Загрузить новый PDF
   - Выполнить поиск (без переиндексации)
   - Проверить:
     - ✅ Новый файл НЕ найден (он не в индексе)
   - Нажать «Построить индекс» снова
   - Проверить:
     - ✅ Индекс пересоздан с учётом нового файла
     - ✅ Поиск теперь находит новый файл

**Критерии успеха (общий флоу):**
- ✅ pdf_reader вызывается ТОЛЬКО при построении индекса (POST /build_index)
- ✅ Поиск работает ТОЛЬКО с индексом, без чтения исходных файлов
- ✅ Индекс — единый сводный файл `_search_index.txt` со всем текстом
- ✅ После построения индекса исходные файлы не читаются до следующей переиндексации
- ✅ Пользователь не видит изменений в работе UI

**Критерии успеха (модуль pdf_reader):**
- Все 5 сценариев проходят без критических ошибок
- Приложение работает как с OCR, так и без него
- Существующая функциональность не нарушена
- Производительность в допустимых пределах

### 9. Миграция и обратная совместимость

**Стратегия миграции (без нарушения работы приложения):**

1. **Фаза 1: Создание модуля (параллельно с существующим кодом)**
   - Создать document_processor/pdf_reader/ со всей логикой
   - Старый код (pdf_utils, indexer._extract_pdf) пока не трогать
   - Написать тесты для нового модуля
   - Контроль: новые тесты проходят, старые тесты не затронуты

2. **Фаза 2: Интеграция в Indexer (осторожное переключение)**
   - В indexer._extract_text() для ext=='pdf': использовать PdfReader, но оставить fallback на старую логику при ошибках
   - Контроль: запустить полный набор тестов, включая test_indexer_basic.py, test_pdf_pypdf_fallback.py
   - Если тесты проходят → убрать fallback

3. **Фаза 3: Обновление pdf_utils (с обратной совместимостью)**
   - Удалить дублирующие функции, добавить импорты из pdf_reader
   - Контроль: проверить, что код, который импортирует из pdf_utils, всё ещё работает

4. **Фаза 4: Удаление устаревшего кода**
   - Удалить indexer._extract_pdf() полностью
   - Очистить неиспользуемые импорты
   - Контроль: все тесты проходят, линтеры не ругаются

**Контрольные точки (checkpoint):**
- ✅ Checkpoint 1: pdf_reader модуль создан, базовые тесты проходят
- ✅ Checkpoint 2: Indexer использует pdf_reader, старые тесты проходят
- ✅ Checkpoint 3: pdf_utils обновлён, обратная совместимость сохранена
- ✅ Checkpoint 4: Дублирование удалено, финальное тестирование успешно

**Откат при проблемах:**
- Если на любом этапе что-то ломается → откат к предыдущему checkpoint через git
- Сохранять коммиты после каждой фазы для возможности быстрого отката

### 10. Риски и меры
- **Отсутствие системных зависимостей** (poppler/tesseract):
  - Мера: graceful degrade, логирование WARNING, документация по установке
  - Приложение продолжает работать для векторных PDF
  
- **Медленные/большие PDF**:
  - Мера: лимиты по времени (budget_seconds) и страницам (max_pages_text, max_pages_ocr)
  - Конфигурируемые параметры в config.py
  
- **Качество OCR на плохих сканах**:
  - Мера: текущая реализация — базовый OCR без предобработки
  - Будущее улучшение: opencv для предобработки (за рамками этого приращения)
  
- **Поломка существующих тестов**:
  - Мера: поэтапная миграция с контрольными точками
  - Запуск полного набора тестов после каждой фазы
  
- **Конфликт импортов при рефакторинге**:
  - Мера: добавить алиасы в pdf_utils.py для обратной совместимости
  - Проверить все места, где импортируется pdf_utils или indexer

## Реализация (простыми словами)

### Этапы разработки:

1. **Создание выделенного модуля pdf_reader:**
   - Создать папку `document_processor/pdf_reader/` с __init__.py, reader.py, analyzer.py, exceptions.py
   - Перенести логику из pdf_utils.py и indexer._extract_pdf() в новый модуль
   - Реализовать класс PdfReader с методами read_pdf(), has_text_layer(), каскадные экстракторы
   - Реализовать класс PdfAnalyzer с analyze_pdf()

2. **Устранение дублирования:**
   - В pdf_utils.py: удалить analyze_pdf() и extract_text_pdf(), оставить только build_pdf_response()
   - Добавить импорты для обратной совместимости: `from .pdf_reader import PdfReader, analyze_pdf`
   - В indexer.py: удалить метод _extract_pdf(), заменить вызовом PdfReader().read_pdf()
   - Переработать ветку для ext=='pdf' в _extract_text() на использование pdf_reader

3. **Определение типа PDF:**
   - has_text_layer() проверяет наличие текста на 2 выборочных страницах
   - Порог: если текст короче PDF_TEXT_MIN_LEN символов → считать сканом
   - Если has_text_layer() == True → векторное извлечение
   - Если False или ocr='force' → OCR

4. **Извлечение текста:**
   - Векторный: каскад pdfplumber → pypdf → pdfminer → PyMuPDF с тайм-бюджетом
   - OCR: pdf2image → pytesseract для первых N страниц
   - Нормализация: NFKC, удаление невидимых символов, схлопывание пробелов
   - Логирование: INFO для старта/финиша, DEBUG для попыток, WARNING при отсутствии зависимостей

5. **Интеграция с Indexer:**
   - В _extract_text() для ext=='pdf': вызов PdfReader().read_pdf()
   - Передача конфига через self._config (если доступен) или дефолтные значения
   - Метаданные: сохранение совместимости с meta['ocr'], meta['format'], meta['length']

6. **Настройка конфигурации:**
   - Добавить параметры PDF_TEXT_TIMEOUT_S, PDF_OCR_ENABLED, PDF_OCR_MAX_PAGES, PDF_OCR_LANG, PDF_TEXT_MIN_LEN в webapp/config.py
   - Использовать эти параметры в PdfReader и Indexer

7. **Установка зависимостей:**
   - Проверить requirements.txt: все необходимые пакеты с версиями
   - Добавить инструкции по установке системных зависимостей (poppler, tesseract) для macOS/Linux
   - Создать скрипт проверки зависимостей

8. **Тестирование:**
   - Написать tests/test_pdf_reader_module.py (базовые быстрые тесты)
   - Написать tests/test_pdf_reader_ocr.py (OCR-тесты с skipif)
   - Написать tests/test_indexer_pdf_refactored.py (интеграционные)
   - Проверить, что существующие тесты (test_pdf_pypdf_fallback.py, test_resilience_broken_files.py) проходят
   - Все тесты с timeout (5-30 сек)

9. **Проверка обратной совместимости:**
   - Запустить полный набор тестов: `pytest -v`
   - Проверить индексацию через UI: загрузить PDF, построить индекс, проверить поиск
   - Убедиться, что приложение не ломается при отсутствии OCR-зависимостей

10. **Документация:**
    - Обновить README.md: раздел с установкой зависимостей
    - Добавить примеры использования PdfReader для разработчиков
    - Описать конфигурационные параметры

### Критерии готовности:
- ✅ Создан отдельный модуль pdf_reader с чистым API
- ✅ Устранено дублирование кода между pdf_utils.py и indexer.py
- ✅ Все зависимости прописаны в requirements.txt с версиями
- ✅ Системные зависимости задокументированы для macOS/Linux
- ✅ Написаны автотесты с таймаутами (базовые + OCR)
- ✅ Существующие тесты проходят без изменений
- ✅ Приложение работает корректно с установленными и без установленных OCR-зависимостей
- ✅ Логирование настроено, ошибки логируются без падений
- ✅ Обратная совместимость: старый код может импортировать функции из pdf_utils

## Итоговый чек-лист реализации

### Обязательные пункты (должны быть выполнены):

**Архитектура:**
- [ ] Создана папка document_processor/pdf_reader/ с __init__.py
- [ ] Создан reader.py с классом PdfReader и методами read_pdf(), has_text_layer()
- [ ] Создан analyzer.py с классом PdfAnalyzer и методом analyze_pdf()
- [ ] Создан exceptions.py с исключениями PdfReadError, OcrNotAvailableError (если нужны)

**Устранение дублирования:**
- [ ] Из pdf_utils.py удалены analyze_pdf() и extract_text_pdf() (логика перенесена в pdf_reader)
- [ ] В pdf_utils.py добавлены алиасы для обратной совместимости
- [ ] Из indexer.py удалён метод _extract_pdf()
- [ ] В indexer._extract_text() для ext=='pdf' используется PdfReader
- [ ] Проверка: `grep -r "def _extract_pdf" document_processor/` не находит дублирующий метод

**Зависимости:**
- [ ] requirements.txt содержит все необходимые пакеты с версиями
- [ ] Документация по установке системных зависимостей (macOS/Linux) добавлена в increment или README
- [ ] Создан скрипт проверки зависимостей (опционально, но желательно)

**Конфигурация:**
- [ ] В webapp/config.py добавлены параметры: PDF_TEXT_TIMEOUT_S, PDF_OCR_ENABLED, PDF_OCR_MAX_PAGES, PDF_OCR_LANG, PDF_TEXT_MIN_LEN, PDF_MAX_PAGES_TEXT
- [ ] Значения по умолчанию установлены безопасные (не ломают существующие тесты)

**Тестирование:**
- [ ] Написан tests/test_pdf_reader_module.py (базовые тесты, timeout 5-10 сек)
- [ ] Написан tests/test_pdf_reader_ocr.py (OCR-тесты с skipif, timeout 30 сек)
- [ ] Написан tests/test_indexer_pdf_refactored.py (интеграционные тесты)
- [ ] Написан tests/test_pdf_from_archive.py (КРИТИЧНО: PDF из ZIP/RAR, timeout 20-30 сек)
- [ ] pytest.ini обновлён (добавлены новые тесты в python_files, включая test_pdf_from_archive.py)
- [ ] Все новые тесты с декоратором @pytest.mark.timeout()
- [ ] OCR-тесты с @pytest.mark.skipif(not OCR_AVAILABLE, ...)

**Обратная совместимость:**
- [ ] Запущены существующие тесты: `pytest tests/test_pdf_pypdf_fallback.py -v` ✅
- [ ] Запущены существующие тесты: `pytest tests/test_resilience_broken_files.py -v` ✅
- [ ] Запущены существующие тесты: `pytest tests/test_indexer_basic.py -v` ✅
- [ ] Запущен полный набор дефолтных тестов: `pytest -v` ✅
- [ ] Проверена работа с DOCX/XLSX/архивами (не PDF) — всё работает

**Сохранение общей логики приложения (КРИТИЧНО):**
- [ ] Загрузка файлов (POST /upload) работает без изменений — pdf_reader НЕ вызывается
- [ ] Построение индекса (POST /build_index) работает — pdf_reader вызывается только здесь
- [ ] Поиск (POST /search) работает только с индексом — pdf_reader НЕ вызывается
- [ ] Исходные файлы НЕ читаются повторно после построения индекса
- [ ] Индекс создаётся в файл `index/_search_index.txt` (единый сводный файл)
- [ ] Все HTTP-ручки работают без изменений (pdf_reader инкапсулирован в indexer)
- [ ] UI не изменился — пользователь не видит отличий в работе приложения

**Функциональность:**
- [ ] Модуль корректно определяет тип PDF (векторный vs скан)
- [ ] Каскад экстракторов работает для векторных PDF
- [ ] OCR работает для сканов (при наличии tesseract)
- [ ] Graceful degradation при отсутствии OCR-зависимостей
- [ ] Тайм-бюджеты соблюдаются, нет зависаний
- [ ] Нормализация текста работает корректно
- [ ] PDF из архивов (ZIP/RAR) корректно извлекаются и обрабатываются PdfReader
- [ ] Метаданные источника для PDF из архивов содержат правильный формат (zip://... или rar://...)

**Логирование:**
- [ ] Логи пишутся в logs/app.log
- [ ] INFO для старта/финиша чтения PDF
- [ ] DEBUG для попыток экстракторов
- [ ] WARNING при отсутствии OCR-зависимостей
- [ ] ERROR с трейсбэком для критических ошибок

**Мануальное тестирование:**
- [ ] Сценарий 1: Базовая функциональность (без OCR) ✅
- [ ] Сценарий 2: Работа с OCR (если установлен tesseract) ✅
- [ ] Сценарий 3: Graceful degradation (без tesseract) ✅
- [ ] Сценарий 4: Производительность ✅
- [ ] Сценарий 5: PDF из архивов (КРИТИЧНО) ✅
- [ ] Сценарий 6: Обратная совместимость ✅
- [ ] Сценарий 7: Проверка общего флоу (загрузка → индекс → поиск) (КРИТИЧНО) ✅

**Документация:**
- [ ] Раздел в README.md с установкой зависимостей обновлён
- [ ] Примеры использования PdfReader для разработчиков добавлены (опционально)
- [ ] Конфигурационные параметры описаны

### Опциональные пункты (желательно, но не критично):
- [ ] Скрипт автоматической проверки зависимостей (tests/check_deps.py)
- [ ] Примеры использования в docstring
- [ ] Type hints для всех публичных методов
- [ ] Линтеры проходят без ошибок (flake8, mypy)

## Примечания
- Настройка предобработки изображений (opencv) и полноценная асинхронность — за рамками данного приращения, могут быть добавлены позже.
- Убедиться, что значения конфигов задокументированы в README и не ухудшают существующие тесты.
- При отсутствии OCR-зависимостей (tesseract/poppler) модуль работает в режиме graceful degradation: логирует WARNING и обрабатывает только векторные PDF.
- Все изменения в отдельной ветке, после тестирования — merge в main с squash-коммитом.
- После завершения реализации обновить метаданные в начале файла: дата/время пуша и commit hash.
