# Техническая постановка и план: модуль обработки файлов для «Анализ Документов Закупки»

Обновлено: 2025-09-28

## Цель

Разработать отдельный модуль обработки файлов, который:
- Создаёт сводный текстовый файл из набора документов (c поддержкой вложенных папок и архивов ZIP/RAR),
- Выполняет быстрый и точный поиск по ключевым словам в сводном файле, игнорируя строки заголовков,
- Корректно извлекает текст (включая OCR картинок), учитывает кириллицу и различные кодировки, версии офисных форматов и повреждённые/сложные документы,
- Добавляет к каждому документу техинформацию (кол-во символов, формат, дата, источник и др.).

## Область применения

Модуль интегрируется во Flask-приложение, но остаётся изолированным и переиспользуемым. Точка входа — путь к папке с документами; модуль рекурсивно обрабатывает вложенные каталоги, а также содержимое архивов ZIP и RAR, формируя единый индексный файл в корне выбранной папки.

Примечание по UI (точечные требования):
- Заголовок интерфейса: «Анализ Документов Закупки».
- После выбора папки рядом с кнопкой «Выбрать папку» отображается полный путь выбранной папки (по webkitRelativePath).
- В списке «Файлы» все имена документов кликабельны и открываются в новой вкладке (inline) через эндпоинт /download, включая неподдерживаемые форматы; неподдерживаемые помечены в списке как «Неподдерживаемый формат».

## Ключевые требования

### 1) Часть 1 — Формирование сводного текстового файла

- Вход: путь к папке (root_folder).
- Рекурсивный обход вложенных папок.
- Обработка файлов поддерживаемых типов: PDF, DOC, DOCX, XLS, XLSX, TXT, а также ZIP и RAR архивы.
- Для ZIP/RAR:
  - Сканирование содержимого архива, извлечение каждого поддерживаемого файла во временную директорию (по умолчанию),
  - Индексация с сохранением виртуального пути источника вида:
    - zip://относительный/путь/к/архиву.zip!/путь/внутри/архива/файл.docx
    - rar://относительный/путь/к/архиву.rar!/путь/внутри/архива/файл.pdf
  - Поддержка имён с кириллицей внутри архива.
  - Защита от ZipSlip (нормализация путей, запрет выхода за пределы временной директории).
  - Ограничения для безопасности и производительности (размер/кол-во файлов, глубина вложения архивов).
- Для каждого документа модуль извлекает текст, учитывая картинки (OCR), нормализует его, считает метрики (число символов и др.).
- Итоговый файл: _search_index.txt (UTF-8) создаётся в корне root_folder.
- Формат сводного файла (повторяется для каждого документа):
  
  ================================
  ЗАГОЛОВОК: [ОТНОСИТЕЛЬНЫЙ_ПУТЬ_ДОКУМЕНТА_ИЛИ_ИСТОЧНИК]
  Формат: [PDF|DOC|DOCX|XLS|XLSX|TXT] | Символов: [N] | Дата: [YYYY-MM-DD HH:MM] | OCR: [да/нет] | Качество: [0–100%]
  Источник: [filesystem|zip://...|rar://...]
  ================================
  [Нормализованный текст документа]

- Порядок включения в индекс: лексикографически по относительному пути (папки/файлы), затем содержимое архивов.
- Кодировки: при чтении применяется автоопределение, при записи всегда UTF-8.

### 2) Часть 2 — Поиск по ключевым словам

- Поиск производится только по _search_index.txt, а не по исходным файлам.
- Заголовки игнорируются (строки между «===…» и строками, начинающимися с «ЗАГОЛОВОК:», «Формат:», «Источник:»).
- Поддержка нескольких ключевых слов, регистронезависимый поиск, Unicode-совместимый.
- Возврат контекстных фрагментов (по умолчанию ±80 символов вокруг совпадения) и указателя на документ (относительный путь/источник из заголовка).
- Ранжирование (простое): документы с большим числом совпадений — выше.

Дополнительно (UI после индексации)
- В списке файлов отображать количество распознанных символов (метрика из сводного индекса). Если значение равно 0 — подсвечивать файл красным.
- Файлы неподдерживаемых форматов также показывать в списке с пометкой «Неподдерживаемый формат» (красным).
- Файлы поддерживаемых форматов, которые не удалось прочитать/проиндексировать, отмечать как «Ошибка чтения или не проиндексирован» (красным).

Исключения и служебные файлы
- Временные файлы офисных приложений (начинаются с `~$` или `$`) не загружаются, не отображаются в списке и не индексируются.

### 3) OCR и обработка изображений

- OCR: pytesseract (языковые пакеты rus, eng), автоматический выбор языков «rus+eng».
- Поддержка изображений внутри PDF (pdfplumber) и DOCX (python-docx, извлечение media/*), а также картинок из страниц PDF (pdf2image => Pillow => OCR).
- Предобработка изображений: преобразование в оттенки серого, бинаризация, увеличение резкости/контраста при необходимости.
- Конфигурация: лимит страниц для OCR, таймаут, макс. разрешение.

### 4) Кодировки, нормализация и качество текста

- Автоопределение кодировки (chardet), fallback: UTF-8 → cp1251 → cp866 → iso-8859-1.
- Нормализация Unicode: NFKC, удаление невидимых/управляющих символов, схлопывание пробелов.
- Метрики качества: длина текста, доля буквенных символов, процент кириллицы, средняя длина слова.
- «Качество» (0–100%) рассчитывается как агрегат метрик (для справки в заголовке).

### 5) Поддержка форматов

- PDF: pdfplumber (основной), pypdf (fallback), OCR для сканов.
- DOCX: python-docx, извлечение параграфов/таблиц; извлечение картинок для OCR.
- DOC: docx2txt (fallback), бинарное извлечение осмысленных слов (как сейчас — улучшить), рекомендации по конвертации.
- XLSX: openpyxl — сбор текстов из ячеек (не формулы), лист за листом.
- XLS: xlrd — обработка старых Excel; если отсутствует — рекомендация конвертировать.
- TXT: чтение с автоопределением кодировки.
- ZIP: стандартный модуль zipfile (безопасная распаковка во временную папку).
- RAR: библиотека rarfile; системная зависимость — «unrar» (brew install unrar на macOS). Если unrar недоступен — пропуск с записью в лог.

### 6) Обработка вложенных папок и архивов

- Рекурсивный обход директорий с ограничением глубины (по умолчанию 10), предотвращение циклов (игнор символических ссылок по умолчанию).
- Архивы:
  - По умолчанию поддерживается однократное вложение архивов (архив внутри архива — отключено), опционально — глубина архивов до 2–3 с ограничениями размера.
  - Ограничение размера архива (например, 500 МБ) и количества элементов (например, 5000).
  - Пропуск и логирование: пустые, защищённые паролем, повреждённые архивы.
  - Безопасные имена и пути (нормализация, фильтрация «..», абсолютных путей и спец-символов).

### 7) Производительность и кэширование

- Кэширование результатов извлечения текста (по хешу файла и времени изменения mtime) в локальном кэше (например, .cache/document_processor).
- Параллелизм: ограниченный пул потоков/процессов для извлечения текста и OCR (конфигурируемо).
- Лимиты на размер/страницы для OCR и pdfplumber (для больших PDF — выборочно).

### 8) Логирование и отчётность

- Детальные логи по каждому документу/архиву (извлечено символов, время, ошибки, источники).
- Сводный отчёт по завершении: количество обработанных файлов, пропущенных, ошибок, время.

## Архитектура модуля

```
document_processor/
├── __init__.py
├── core.py              # DocumentProcessor: координация, API
├── extractors/
│   ├── __init__.py
│   ├── base.py          # Базовый интерфейс Extractor
│   ├── pdf_extractor.py
│   ├── docx_extractor.py
│   ├── doc_extractor.py
│   ├── excel_extractor.py
│   ├── text_extractor.py
│   └── archive_extractor.py   # ZIP/RAR
├── ocr/
│   ├── __init__.py
│   ├── tesseract_ocr.py
│   └── image_processor.py
├── utils/
│   ├── __init__.py
│   ├── encoding_detector.py
│   ├── file_validator.py
│   ├── path_utils.py          # безопасная работа с путями, zip-slip защита
│   └── text_cleaner.py
└── search/
    ├── __init__.py
    ├── indexer.py       # генерация _search_index.txt
    └── searcher.py      # поиск по индексу с игнорированием заголовков
```

### Публичное API (черновик)

```python
class DocumentProcessor:
    def create_search_index(self, root_folder: str) -> str:
        """Рекурсивно обходит root_folder, обрабатывает вложенные папки и архивы,
        строит _search_index.txt в root_folder, возвращает путь к индексу."""

    def search_keywords(self, index_path: str, keywords: list[str], context: int = 80) -> list[dict]:
        """Ищет keywords в индексе, игнорируя заголовки. Возвращает список совпадений
        с полями: source, match, context_before, context_after, positions."""

    def get_file_stats(self, source: str) -> dict:
        """Возвращает техинформацию по документу (формат, длина, качество, источник, время)."""
```

## Формальные контракты

- Вход: root_folder — существующая директория с документами/архивами.
- Выход: _search_index.txt в root_folder (UTF-8).
- Ошибки: не падать на единичных ошибках; логировать и продолжать. Возврат информативных сообщений.

## Игнорирование заголовков при поиске

- Строки заголовков начинаются с «ЗАГОЛОВОК:», «Формат:», «Источник:», а также разделители «====…». Они исключаются из поиска.
- Реализация: при поиске читатель пропускает блоки заголовков (до следующей пустой строки после разделителя) или применяет маску по регулярным выражениям:
  - ^=+
  - ^ЗАГОЛОВОК:\s
  - ^Формат:\s
  - ^Источник:\s

## Псевдокод (индексация с вложенными папками и архивами)

```text
function create_search_index(root):
  idx_path = join(root, "_search_index.txt")
  open idx for write UTF-8
  for each item in walk(root) recursively (depth<=MAX_DEPTH):
    if item is file and extension in SUPPORTED:
      process_and_append(item, source=relative_path(item))
    if item is .zip or .rar:
      members = safe_list_archive_members(item)
      if members exceeds limits -> log and skip
      tmpdir = mkdtemp()
      for m in members:
        if m is supported file and safe path:
          extract to tmpdir preserving relative
          process_and_append(extracted_path, source=scheme://archive!member)
      cleanup tmpdir
  close idx
```

Где process_and_append:
- извлекает текст (с OCR при необходимости),
- нормализует, считает метрики,
- пишет заголовок и текст в индексный файл.

## Пограничные случаи и ограничения
 
### Просмотр файлов — дерево решений (добавлено)

- Подсветка терминов на странице просмотра: при наличии параметра `?q=a,b,c` URL выполняется регистронезависимая подсветка найденных слов в видимом тексте.
- Алгоритм открытия `/view/<path>`:
  1) Проверяем безопасный путь, существование и поддержку формата; скрытые файлы — 403.
  2) HTML/HTM: отдаём исходный HTML в шаблоне `view.html`.
  3) TXT/CSV/TSV/JSON/XML: читаем как текст (CSV/TSV рендерим в таблицу) и показываем в `view.html`.
  4) Office/PDF: пробуем извлечь текст (PDF: pdfplumber → pypdf (с расшифровкой) → pdfminer.six → PyMuPDF; DOCX: параграфы + таблицы; DOC: эвристика + docx2txt; XLSX/XLS: ячейки).
  5) Если извлечённый текст не пуст — рендерим в `<pre>` внутри `view.html`.
  6) Если текст пуст — пробуем отдать исходный файл inline (браузерный вьювер, напр. PDF-плагин).
  7) Если браузерный показ не удался — выводим страницу с предложением скачать файл (Да — `/download/<path>?download=1`, Нет — вернуться на главную).

Примечания: скачивание/просмотр используют безопасные пути; ошибки библиотек логируются; UI не падает на сбоях.

- Пустые/повреждённые файлы: помечать в логе, индексировать заголовок с нулевой длиной и сообщением.
- Слишком большие файлы/архивы: пропускать по конфигурации.
- Защищённые паролем ZIP/RAR: пропуск (логировать указание на пароль).
- Архивы внутри архивов: по умолчанию не обрабатываются (config: ARCHIVE_DEPTH=0). Можно включить ограниченно.
- Симлинки/джанк-шорткаты: игнорировать по умолчанию.

## Конфигурация (рекомендации)

- MAX_DEPTH=10
- MAX_ARCHIVE_SIZE_MB=500
- MAX_ARCHIVE_MEMBERS=5000
- ARCHIVE_DEPTH=0 (по умолчанию), можно 1–2
- OCR_ENABLED=True; OCR_LANGS="rus+eng"; OCR_MAX_PAGES=10; OCR_TIMEOUT_SEC=20
- CACHE_DIR=".cache/document_processor"; CACHE_TTL_DAYS=7

## Зависимости

Python-пакеты:
- pdfplumber>=0.11.7
- pypdf>=5.0.0
- python-docx>=0.8.11
- docx2txt>=0.8
- openpyxl>=3.1.2
- xlrd>=2.0.1
- chardet>=5.0.0
- pytesseract>=0.3.10
- Pillow>=10.0.0
- pdf2image>=3.1.0
- rarfile>=4.2

Системные:
- Tesseract OCR + языковые модели rus, eng
- unrar (для rarfile) — macOS: `brew install unrar`

## План реализации

Этап 1. Каркас модуля и API
- Создать пакет document_processor с указанной структурой.
- Реализовать core.DocumentProcessor (заглушки методов) и базовые интерфейсы extractors.
- Добавить utils.path_utils с защитой от ZipSlip и нормализацией путей.

Этап 2. Извлекатели форматов
- pdf_extractor (pdfplumber, pypdf, OCR fallback для сканов).
- docx_extractor (текст + извлечение картинок в OCR).
- doc_extractor (улучшить текущую бинарную стратегию + docx2txt fallback + рекомендации).
- excel_extractor (openpyxl/xlrd) и text_extractor (chardet).

Этап 3. Архивы и рекурсия
- archive_extractor: безопасная распаковка ZIP (zipfile) и чтение RAR (rarfile+unrar) во временные каталоги.
- Реализация ограничений размера, количества элементов, глубины архивов.
- Интеграция с рекурсивным обходом и единым индексатором.

Этап 4. OCR и обработка изображений
- ocr/tesseract_ocr.py и ocr/image_processor.py (предобработка изображений).
- Конфигурация языков и таймаутов, лимиты страниц.

Этап 5. Индексация и метрики
- search/indexer.py: генерация _search_index.txt, заголовки, метрики качества.
- Кэширование результатов (utils + CACHE_DIR).

Этап 6. Поисковик
- search/searcher.py: поиск по индексу с игнорированием заголовков, контекстные сниппеты, простое ранжирование.

Этап 7. Интеграция с Flask (актуально)
- Индекс создаётся автоматически: после загрузки папки, перед поиском и после удаления (UI вызывает POST `/build_index`).
- Поиск работает только по индексу; при отсутствии индекса он создаётся автоматически.
- Просмотр индекса: GET `/view_index` (открывает `_search_index.txt` в новой вкладке).
- Примечание по размещению индекса в веб-приложении: для чистоты списка файлов и удобства UI сводный файл `_search_index.txt` после сборки перемещается из `uploads/` в отдельную папку `index/` на уровне приложения. Бэкенд учитывает новый путь, UI не отображает индекс как пользовательский файл.
- UI: отдельная страница результатов удалена; сниппеты и подсветка выводятся на главной странице.

Этап 8. Тестирование и стабилизация
- Набор тест-документов (PDF сканы, DOC, DOCX с картинками, XLS/XLSX, TXT в cp1251/utf8; ZIP/RAR с кириллицей).
- Тесты производительности, корректности, устойчивости к ошибкам.

## Критерии приёмки

- Индекс создаётся в корне выбранной папки, содержит все поддерживаемые файлы, включая из вложенных папок и архивов.
- Поиск по индексу игнорирует заголовки, находит ключевые слова (в т.ч. кириллица), выдаёт контекст.
- OCR корректно извлекает текст из картинок (рус/англ).
- Логи информативны, ошибки не приводят к падению всего процесса.
- Обработка больших наборов документов выполняется в разумное время с соблюдением лимитов.

---

Примечание: Порт 5000 освобождён для последующей разработки/перезапуска приложения.
