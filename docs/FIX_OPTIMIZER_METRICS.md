# Исправление расхождения в метриках оптимизации текста

## Проблема

При оптимизации текста, даже когда изменения не требуются, метрики показывали небольшую разницу:

```
Символов до: 99 846
Символов после: 99 838
Экономия: 8 (0.0%)
```

## Причина

Оптимизатор выполнял **базовую нормализацию** текста в начале работы:
- Замена `\r\n` → `\n`
- Удаление управляющих символов (кроме `\n`, `\t`)
- Схлопывание множественных пробелов
- Схлопывание пустых строк (max 2 подряд)

Но при этом:
- `chars_before` считался от **исходного** текста (с `\r\n`, лишними пробелами и т.д.)
- `chars_after` считался от **нормализованного** текста

Из-за этого возникало небольшое расхождение (обычно 5-10 символов), даже когда "содержательных" изменений не было.

## Решение

Изменён порядок операций в методе `TextOptimizer.optimize()`:

### Было:
```python
original_text = text
chars_before = len(text)  # Считаем ДО нормализации
change_spans = []

text, spans1 = self._normalize_whitespace(text)  # Нормализуем
# ... остальные правила
chars_after = len(text)  # Считаем ПОСЛЕ нормализации
```

### Стало:
```python
# Сначала нормализуем (базовая очистка не считается оптимизацией)
text, _ = self._normalize_whitespace(text)

# Теперь считаем размер ПОСЛЕ нормализации
original_text = text
chars_before = len(text)
change_spans = []

# Применяем правила оптимизации
# ... остальные правила
chars_after = len(text)
```

## Результат

Теперь метрики корректны:
- Если изменений нет → `chars_before == chars_after` (100%)
- Базовая нормализация (удаление `\r\n`, лишних пробелов) **не считается оптимизацией**
- Только содержательные изменения (удаление декоративных линий, номеров страниц и т.д.) учитываются в метриках

## Изменённые файлы

- `webapp/services/text_optimizer.py` - метод `optimize()`

## Пример после исправления

```
Символов до: 99 838
Символов после: 99 838
Экономия: 0 (0.0%)
```

✅ Метрики точно совпадают, когда изменений не требуется!
