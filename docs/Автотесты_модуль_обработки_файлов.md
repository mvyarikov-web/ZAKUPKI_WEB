# План автотестов: модуль обработки документов (document_processor)

Этот файл описывает, как автоматически проверить работоспособность нового модуля обработки документов: рекурсивная индексация папок и архивов (ZIP/RAR), извлечение текста из основных форматов, базовый OCR, корректная работа с кириллицей/кодировками, генерация сводного файла `_search_index.txt`, и поиск по нему с игнорированием заголовков.

## Цели тестирования
- Подтвердить корректность создания индекса `_search_index.txt` рядом с исходными файлами.
- Проверить извлечение текста: TXT, PDF, DOCX, DOC, XLSX, XLS.
- Проверить рекурсивную обработку вложенных папок и содержимого архивов ZIP и RAR.
- Проверить базовый OCR (DOCX-изображения, 1-я страница PDF) и фолбэки, если Tesseract недоступен.
- Убедиться в устойчивости к кириллице и разным кодировкам (cp1251/cp866/utf-8), а также в нормализации текста.
- Проверить работу поиска: игнор заголовков, корректная выдача сниппетов и сортировка.
- Оценить стабильность: обработка испорченных/неподдерживаемых файлов, очистка временных файлов.

## Инструменты и предпосылки
- Python 3.10+
- Установленные зависимости из `requirements.txt` (включая: chardet, python-docx, openpyxl, pypdf, pdfplumber, pytesseract, Pillow, pdf2image, rarfile).
- Для OCR: установленный Tesseract OCR в системе (macOS: `brew install tesseract`) и, при необходимости, языковые пакеты rus/eng.
- Для RAR: установленный `unrar` (macOS: `brew install unrar`).
- Рекомендуется PyTest для запуска тестов: `pip install pytest pytest-timeout` (можно добавить в dev-зависимости при необходимости).

## Структура автотестов (предлагаемая)
```
/tests
  /fixtures                     # Генерируемые/хранимые тестовые файлы
  test_indexer_basic.py         # Базовые проверки индексации
  test_extractors_formats.py    # Проверки по каждому формату
  test_archives.py              # ZIP и RAR, в т.ч. вложенности
  test_encoding_cyrillic.py     # Кириллица и разные кодировки
  test_ocr.py                   # OCR-проверки (с пропуском, если Tesseract нет)
  test_searcher.py              # Поиск, игнор заголовков, сниппеты
  test_resilience.py            # Ошибки/битые файлы/очистка временных
  conftest.py                   # Общие фикстуры и утилиты
```

## Ключевые фикстуры
- tmp_path (pytest) — временная рабочая директория.
- make_files — вспомогательная фикстура для генерации файлов разных типов на лету:
  - TXT с кириллицей, в том числе сохранённый в cp1251/cp866.
  - DOCX с текстом и картинкой с текстом (для OCR).
  - XLSX/XLS с несколькими ячейками текста.
  - PDF с текстом; опционально — «скан» (изображение с текстом) для OCR.
  - ZIP/RAR архивы с вложенными файлами и структурами папок.
- ensure_env — проверка наличия tesseract/unrar; маркирует тесты `@pytest.mark.skipif` при отсутствии.

## Контракты для тестов (входы/выходы)
- document_processor.core.DocumentProcessor:
  - create_search_index(root_folder: str) -> str
    - Создаёт/пересоздаёт `_search_index.txt` в корне `root_folder`. Возвращает путь к индексу.
  - search_keywords(index_path: str, keywords: list[str], context: int = 80) -> list[dict]
    - Ищет ключевые слова в индексе, игнорируя хедеры. Возвращает массив сниппетов с метаданными.

## Набор тестов

### 1) Базовая индексация (test_indexer_basic.py)
- Создать папку с 3 файлами (txt, docx, xlsx), каждый содержит уникальные слова: «арбуз», «самолёт», «шахматы».
- Вызвать create_search_index(root).
- Проверить:
  - Файл `_search_index.txt` существует в `root`.
  - Для каждого исходного файла присутствует секция с заголовком `====` и метаданными: `File`, `Format`, `Symbols`, `Date`, `OCR`, `Quality`, `Source`.
  - Суммарный текст содержит исходные слова в нормализованном виде (учёт кириллицы, без мусорных символов).

### 2) Поддерживаемые форматы (test_extractors_formats.py)
- TXT: создать файл в UTF-8 и в cp1251, проверить, что текст извлечён и содержит кириллицу «ёж».
- DOCX: с абзацами и таблицей; убедиться, что таблица тоже попала в индекс.
- DOC: создать простой .doc (если генерация затруднена, взять мини-фикстуру заранее или проверить graceful-фолбэк с предупреждением и непустой попыткой извлечь текст, если возможна).
- XLSX и XLS: создать по одному листу с простым текстом; проверить наличие текста в индексе.
- PDF (текстовый): создать короткий PDF с текстом «молоко» и проверить индексацию (можно использовать любой способ генерации или заранее заготовленную фикстуру).

### 3) Рекурсия по папкам (test_indexer_recursion.py)
- Сформировать структуру: root/a/b/file1.txt и root/c/file2.docx.
- Убедиться, что оба файла проиндексированы и отражены в `_search_index.txt` с путями `a/b/file1.txt` и `c/file2.docx`.

### 4) Архивы ZIP/RAR (test_archives.py)
- Создать ZIP c файлами txt/docx во вложенных папках; создать RAR c txt.
- Запустить индексацию и проверить:
  - В индексе есть записи со `Source: zip://...` и `Source: rar://...`.
  - Текст из файлов внутри архивов попал в индекс.
  - Для RAR тест пометить `@pytest.mark.skipif` при отсутствии `unrar`.

### 5) OCR (test_ocr.py)
- DOCX с вставленной картинкой, содержащей слово «арбуз»; проверить, что `OCR: true` и слово присутствует в тексте индекса.
- PDF-«скан» с текстом «океан» на первой странице; проверить, что `OCR: true` и слово найдено.
- Оба теста пометить `@pytest.mark.skipif` при отсутствии Tesseract.

### 6) Кодировки и кириллица (test_encoding_cyrillic.py)
- Создать TXT в cp1251 и cp866 с текстом «Привет, мир!».
- Индексация не должна падать, в индекс должен попасть нормализованный текст с кириллицей.

### 7) Поиск (test_searcher.py)
- По заранее созданному индексу (из 1-2 тестов выше) выполнить `search_keywords` по нескольким словам, включая варианты регистра.
- Проверить:
  - Заголовки индекса не попадают в сниппеты.
  - Возвращаются корректные контексты (окружение ±N символов).
  - Результаты отсортированы в соответствии с логикой (например, по первому вхождению).

### 8) Устойчивость и очистка (test_resilience.py)
- Добавить битый PDF/неподдерживаемый файл `.bin` и убедиться, что индексация не падает.
- Проверить, что временные файлы от распаковки архивов очищаются (например, по отсутствию временных имен после завершения индексации).

### 9) Простая производительность (нестрогая) (test_perf_smoke.py)
- Сгенерировать N=200 простых TXT-файлов по ~2 КБ.
- Индексация должна завершиться за разумное время (порог оговорить, например, < 5 секунд на среднебыстром ноутбуке; оформить как «smoke», без падения сборки на слабых машинах — предупреждение/лог вместо жёсткого ассёрта, или пометить `@pytest.mark.slow`).

## Пример каркаса тестов (фрагменты)

```python
# conftest.py
import os
import sys
import shutil
import zipfile
import pytest

try:
    import rarfile
except Exception:
    rarfile = None

@pytest.fixture
def ensure_env():
    import shutil
    has_tesseract = shutil.which("tesseract") is not None
    has_unrar = shutil.which("unrar") is not None
    return {"tesseract": has_tesseract, "unrar": has_unrar}

@pytest.fixture
def make_txt(tmp_path):
    def _make_txt(name: str, text: str, encoding: str = "utf-8"):
        p = tmp_path / name
        p.write_text(text, encoding=encoding, errors="ignore")
        return p
    return _make_txt
```

```python
# test_indexer_basic.py
import json
from document_processor import DocumentProcessor

def test_index_basic(tmp_path):
    (tmp_path / "root").mkdir()
    root = tmp_path / "root"

    (root / "a.txt").write_text("арбуз", encoding="utf-8")
    try:
        from docx import Document
        d = Document()
        d.add_paragraph("самолёт")
        d.save(root / "b.docx")
    except Exception:
        # Если нет python-docx — пропустить часть, но тест продолжит TXT
        pass
    try:
        import openpyxl
        wb = openpyxl.Workbook()
        ws = wb.active
        ws["A1"] = "шахматы"
        wb.save(root / "c.xlsx")
    except Exception:
        pass

    dp = DocumentProcessor()
    index_path = dp.create_search_index(str(root))

    assert (root / "_search_index.txt").exists()
    assert str(index_path).endswith("_search_index.txt")

    text = (root / "_search_index.txt").read_text(encoding="utf-8", errors="ignore")
    assert "арбуз" in text
    # Наличие метаданных
    assert "Format:" in text and "Symbols:" in text and "Source:" in text
```

```python
# test_searcher.py
from document_processor import DocumentProcessor

def test_search_ignores_headers(tmp_path):
    root = tmp_path / "root"
    root.mkdir()
    (root / "file.txt").write_text("Тут сказано: ЖИРАФ. Ещё раз: жираф.", encoding="utf-8")

    dp = DocumentProcessor()
    index_path = dp.create_search_index(str(root))

    results = dp.search_keywords(index_path, ["жираф"], context=12)
    assert results, "Не найдено совпадений"

    for r in results:
        snippet = r.get("snippet", "")
        assert "====" not in snippet and "Format:" not in snippet
        assert "жираф".lower() in snippet.lower()
```

## Запуск тестов
- Установить dev-зависимости (опционально):
```
pip install pytest pytest-timeout
```
- Запуск всех тестов:
```
pytest -q
```
- Пропуск «медленных» тестов (если пометить `@pytest.mark.slow`):
```
pytest -q -m "not slow"
```

## Примечания
- Тесты OCR и RAR зависят от системного окружения; используйте `@pytest.mark.skipif`.
- Для PDF-«сканов» можно использовать заранее подготовленные изображения с текстом и собирать PDF через `pdf2image`/Pillow или приложить минимальные фикстуры.
- Если потребуется, можно добавить `pytest.ini` с регистрацией собственных маркеров (`slow`, `ocr`, `archives`).

## Критерии приёмки
- Все обязательные тесты (кроме помеченных как `skipif`) проходят на разработческой машине.
- Индекс корректно создаётся и содержит ожидаемые метаданные; поиск возвращает корректные сниппеты без заголовков.
- Обработка архивов и вложенных папок подтверждена тестами.
- OCR-пути работают при наличии Tesseract, а при его отсутствии тесты корректно пропускаются.
